/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------*//**
*
*  \file                common_support_tasks.c
*
*  \brief               The file contains a task which is responsible for counting the run-time seconds of every Sykam device. Another task is
*                       to observe the mainboard voltages dependend on user configuration in \ref AT91SAM7X.h.
*
*
*  \author              Ruediger Radtke
*  \version             1.1
*
*  \date                2011-08-30     Initial version.
*  \date                2011-11-24     Removed code intern word swaps for 32-bit register bank values (NOW they are shown swaped externally).
*  \date                2012-07-13     v1.1 Added task \ref TSK_CommonSupportTasks_MainboardVoltageMonitoring which observes the mainboard voltages.
*
*
*  \bug                 No bugs known at moment. \n
*
*  \test                
*
*  \todo                
*
*
*//*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------*//*
*   Copyright(c) 2010-2011 Sykam GmbH. All rights reserved.
*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>                                             // ### debug
#include <math.h>                                              // ### debug

#include <AT91SAM7X256.h>
#include <lib_AT91SAM7X256.h>

#include "..\..\..\rtl\support.h"
#include "AT91SAM7X.h"

#include "..\..\..\protocol\modbus\mbpbcfg.h"
#include "..\..\..\protocol\modbus\mbpbframe.h"
#include "..\..\..\protocol\modbus\mbpbdata.h"
#include "..\..\..\protocol\modbus\mbpbext.h"

#include "..\..\..\cpu\at91\adc\adc.h"

#include "..\..\..\cpu\at91\rtt\rttext.h"

#include "..\..\..\cpu\at91\usart\usartext.h"                  // ### debug

#include "..\..\..\lib_exceptions_drv\lib_exceptions_drv.h"

#include "lib_exceptions.h"
#include "lib_exceptions_funcs.h"
#include "common_registers.h"
#include "utils_funcs.h"

//---------------------------------------------- externals used in this file -------------------------------------------------------------------

extern            OS_SEM                                    SEM_CommonSupportFuncs_DeviceRunTimeCounter;
//extern            tS_AT91SAM7X_MainboardVoltageMonitoring   SA_AT91SAM7X_MainboardVoltageMonitoring[];
extern   const    ushort                                    cu16_UtilsFuncs_TimeoutShort;
extern   const    ushort                                    cu16_UtilsFuncs_TimeoutMedium;
extern   const    ushort                                    cu16_UtilsFuncs_TimeoutLong;
extern   const    U32                                       os_clockrate;

//------------------------------------------------ tasks ---------------------------------------------------------------------------------------

__task void TSK_CommonSupportTasks_DeviceRunTimeCounter (void)
{
   U32                           u32_DeviceRunTimeCounter;
   uchar                         u8_Unit                    =  0;
   tS_LibExceptions_Exceptions   S_Exceptions;
   
   
   // reset of structure is necessary!
   memset ((void *)(&S_Exceptions), 0, (size_t)sizeof(S_Exceptions));
   
   
   FOREVER
   {
      // wait for semaphore
      if (OS_SEM_TAKE_CHK(os_sem_take(SEM_CommonSupportFuncs_DeviceRunTimeCounter, OS_T_FOREVER)))
      {
         if (SUCCESS (RttRead (u8_Unit, &u32_DeviceRunTimeCounter, cu16_UtilsFuncs_TimeoutMedium),
                      S_Exceptions.u32_ErrorCodeSW_Sub, (ulong)LIB_EXCEPTIONS__ERROR__COMMON_SUPPORT_TASKS__TSK_DEVICE_RUN_TIME_COUNTER))
         {
            // store device run-time to permanent memory
            if (SUCCESS_APP_FUNC (UtilsFuncs_FixedMemDataPackagesRW ((void *)(&u32_DeviceRunTimeCounter), (ushort)AT91SAM7X__NUM_REGS_4, 
                                                                     (ushort)(COMMON_REGISTERS__FRAM_ADDR__DEVICE_RUN_TIME_COUNTER),
                                                                     (bool)UTILS_FUNCS__WRITE),
                                  S_Exceptions.u32_ErrorCodeSW_Sub))
            {                 
               // write total run-time to register bank
               TRY_AND_CATCH
               (  
                  MBPBRegAccess ((uchar)MBPB_REGTYPE_INPUT, (bool)MBPB_REGRW_WRITE, 
                                 (ushort)COMMON_REGISTERS__MODBUS_ADDR_IREG__DEVICE_RUN_TIME_COUNTER, (ushort)AT91SAM7X__NUM_REGS_2, 
                                 (void *)(&u32_DeviceRunTimeCounter), NULL, cu16_UtilsFuncs_TimeoutShort),
                  S_Exceptions.u32_ErrorCodeSW_Sub, (ulong)LIB_EXCEPTIONS_DRV__ERROR__MODBUS__REGACCESS
               );
            }
         }
         
         if (S_Exceptions.u32_ErrorCodeSW_Sub)
         {
            S_Exceptions.u16_ErrorCodeSW_Base = (ushort)LIB_EXCEPTIONS__ERROR__COMMON_SUPPORT_TASKS__TSK_DEVICE_RUN_TIME_COUNTER;
            
            // set error codes to register bank
            LibExceptionsFuncs_ExceptionSet (&S_Exceptions);
            
            // update display
            AT91F_PIO_ClearOutput (AT91SAM7X__BASE_PIO__DISP0_ATN, AT91SAM7X__PIN__DISP0_ATN);
         }
      }
   }
}

//----------------------------------------------------------------------------------------------------------------------------------------------

//__task void TSK_CommonSupportTasks_MainboardVoltageMonitoring (void)
//{
//   uchar                         u8_AdcChannel; 
//   uchar                         u8_AdcChannelId;
//   uchar                         u8_Result                                 =  0;
//   ushort                        u16_VoltageMonitoringDisabled;
//   ushort                        u16_CurrentMainboardVoltageInMilliVolt;
//   ushort                        u16_AdcResolutionSteps;
//   ushort                        u16_Address;
//   ushort                        u16A_AdcData[AT91SAM7X__ADC_CHANNELS_MAX];
//   ushort                        u16_TimeoutSampleAndHold;
//   ushort                        u16_TimeoutDriver;
//   
//   AT91PS_ADC                    pS_Adc                                    =  AT91C_BASE_ADC;
//   tS_LibExceptions_Exceptions   S_Exceptions;
//   
//   char  s8A_UsartDataTx[300];         // ### debug
//   
//   // reset of structure is necessary!
//   memset ((void *)(&S_Exceptions), 0, (size_t)sizeof(S_Exceptions));
//   
//   
//   // check if at least selected user channels, to be enabled during init, are enabled (init done)
//   for (u8_AdcChannelId = 1; u8_AdcChannelId < (uchar)AT91C_ADC_CH7; u8_AdcChannelId = u8_AdcChannelId << 1)
//   {
//      if (u8_AdcChannelId & (uchar)pS_Adc->ADC_CHSR)
//         u8_Result += u8_AdcChannelId;
//   }
//   
//   if ((uchar)AT91SAM7X__ADC_CHANNELS_FOR_MAINBOARD_VOLTAGE_MONITORING != 0)
//   {
//      if (u8_Result >= (uchar)AT91SAM7X__ADC_CHANNELS_FOR_MAINBOARD_VOLTAGE_MONITORING)
//      {
//         FOREVER
//         {
//            // set task variables
//            u16_TimeoutSampleAndHold   =  (ushort)AT91SAM7X__TICK_1;
//            u16_TimeoutDriver          =  cu16_UtilsFuncs_TimeoutShort;
//            pS_Adc                     =  AT91C_BASE_ADC;
//            
//            // retrieve ADC data
//            if (SUCCESS (AdcGetConvertedData ((uchar)AT91SAM7X__ADC_CHANNELS_FOR_MAINBOARD_VOLTAGE_MONITORING, &u16A_AdcData[0], 
//                                              u16_TimeoutSampleAndHold, u16_TimeoutDriver),
//                         S_Exceptions.u32_ErrorCodeSW_Sub, (ulong)LIB_EXCEPTIONS_DRV__ERROR__ADC__GET_CONVERTED_DATA))
//            {
//               // reset channel number
//               u8_AdcChannel = 0;
//               
//               // search for active voltage monitoring channels
//               for (u8_AdcChannelId = 1; u8_AdcChannelId < (uchar)AT91C_ADC_CH7; u8_AdcChannelId = u8_AdcChannelId << 1)
//               {
//                  if (u8_AdcChannelId & (uchar)AT91SAM7X__ADC_CHANNELS_FOR_MAINBOARD_VOLTAGE_MONITORING)
//                  {
//                     // set ADC resolution steps
//                     if (!(pS_Adc->ADC_MR & (ulong)AT91C_ADC_LOWRES_10_BIT))     // caution: mask is zero
//                        u16_AdcResolutionSteps = 0x03FF;
//                     else if (pS_Adc->ADC_MR & (ulong)AT91C_ADC_LOWRES_8_BIT)
//                        u16_AdcResolutionSteps = 0x00FF;
//                     else
//                     {
//                        S_Exceptions.u32_ErrorCodeSW_Sub = (ulong)LIB_EXCEPTIONS__ERROR_SPECIAL__ADC_INTERNAL_NOT_INITIALIZED;
//                        break;
//                     }
//                     
//                     // convert current ADC value into voltage [mV]
//                     u16_CurrentMainboardVoltageInMilliVolt =  AT91SAM7X__CONVERT_ADC_VALUE_INTO_VOLTAGE((ulong)(u16_AdcResolutionSteps & u16A_AdcData[u8_AdcChannel]), (ulong)u16_AdcResolutionSteps, (ulong)AT91SAM7X__ADC_VREF_IN_MILLIVOLT);
//                     
//                     // calc the present voltage at reference value according to voltage divider rule (no floats necessary)
//                     u16_CurrentMainboardVoltageInMilliVolt =  u16_CurrentMainboardVoltageInMilliVolt * 
//                                                               ((SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u32_VoltageDividerResistanceFar  + 
//                                                                 SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u32_VoltageDividerResistanceNear   ) / 
//                                                                SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u32_VoltageDividerResistanceNear);
//                     
//                     // determine correct register bank address for mainboard voltage
//                     if (SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u16_VoltageReferenceInMilliVolt > (ushort)AT91SAM7X__MAINBOARD_VOLTAGE_REFERENCE_5000_MILLIVOLT)
//                     {
//                        u16_Address = (ushort)COMMON_REGISTERS__MODBUS_ADDR_IREG__MAINBOARD_CURRENT_VOLTAGE_AT_24000_MV;
//                     }
//                     else if (SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u16_VoltageReferenceInMilliVolt > (ushort)AT91SAM7X__MAINBOARD_VOLTAGE_REFERENCE_3300_MILLIVOLT)
//                     {
//                        u16_Address = (ushort)COMMON_REGISTERS__MODBUS_ADDR_IREG__MAINBOARD_CURRENT_VOLTAGE_AT_5000_MV;
//                     }
//                     else if (   (SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u16_VoltageReferenceInMilliVolt > 0)
//                              && (SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u16_VoltageReferenceInMilliVolt < (ushort)AT91SAM7X__MAINBOARD_VOLTAGE_REFERENCE_5000_MILLIVOLT)
//                             )
//                     {
//                        u16_Address = (ushort)COMMON_REGISTERS__MODBUS_ADDR_IREG__MAINBOARD_CURRENT_VOLTAGE_AT_3300_MV;
//                     }
//                     else
//                     {
//                        S_Exceptions.u32_ErrorCodeSW_Sub = (ulong)LIB_EXCEPTIONS__ERROR_SPECIAL__ADC_INTERNAL_NOT_INITIALIZED;
//                        break;
//                     }
//                       
//                     // write mainboard voltage value into register bank
//                     if (SUCCESS (MBPBRegAccess ((uchar)MBPB_REGTYPE_INPUT, (bool)MBPB_REGRW_WRITE, u16_Address, 
//                                                 (ushort)AT91SAM7X__NUM_REGS_1, (void *)(&u16_CurrentMainboardVoltageInMilliVolt),
//                                                  NULL, cu16_UtilsFuncs_TimeoutShort),
//                                  S_Exceptions.u32_ErrorCodeSW_Sub, (ulong)LIB_EXCEPTIONS_DRV__ERROR__MODBUS__REGACCESS))
//                     {
//                        // read voltage monitoring status
//                        if (SUCCESS (MBPBRegAccess ((uchar)MBPB_REGTYPE_HOLDING, (bool)MBPB_REGRW_READ, 
//                                                    (ushort)COMMON_REGISTERS__MODBUS_ADDR_HREG__MAINBOARD_VOLTAGE_MONITORING, (ushort)AT91SAM7X__NUM_REGS_1, 
//                                                    (void *)(&u16_VoltageMonitoringDisabled), NULL, cu16_UtilsFuncs_TimeoutShort),
//                                     S_Exceptions.u32_ErrorCodeSW_Sub, (ulong)LIB_EXCEPTIONS_DRV__ERROR__MODBUS__REGACCESS))
//                        {
//                           // go ahead if mainboard voltage monitoring is enabled
//                           if (!u16_VoltageMonitoringDisabled)
//                           {
//                              // check if mainboard voltage is out of range
//                              if (u16_CurrentMainboardVoltageInMilliVolt < SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u16_VoltageThresholdInMilliVoltLow)
//                                 S_Exceptions.u32_ErrorCodeSW_Sub = (ulong)LIB_EXCEPTIONS__ERROR_SPECIAL__MAINBOARD_LOW_VOLTAGE;
//                              else if (u16_CurrentMainboardVoltageInMilliVolt > SA_AT91SAM7X_MainboardVoltageMonitoring[u8_AdcChannel].u16_VoltageThresholdInMilliVoltHigh)
//                                 S_Exceptions.u32_ErrorCodeSW_Sub = (ulong)LIB_EXCEPTIONS__ERROR_SPECIAL__MAINBOARD_HIGH_VOLTAGE;
//                           }
//   //                     
//   //      // debug
//   //            sprintf ((char *)s8A_UsartDataTx, "adc_data ch%d = %d %d mV\t", u8_AdcChannel, (ulong)(0x03FF & u16A_AdcData[u8_AdcChannel]), u16_CurrentMainboardVoltageInMilliVolt);
//   //            
//   //            UsartTx (0, 0, s8A_UsartDataTx, strlen((const char *)s8A_UsartDataTx), OS_T_MS(100));
//   //      // debug end
//   //                     
//                        }
//                     }
//                  }
//                  // increment channel number
//                  u8_AdcChannel++;
//               }
//            }
//            
//            if (S_Exceptions.u32_ErrorCodeSW_Sub)
//            {
//               S_Exceptions.u16_ErrorCodeSW_Base   = (ushort)LIB_EXCEPTIONS__ERROR__COMMON_SUPPORT_TASKS__TSK_MAINBOARD_VOLTAGE_MONITORING;
//            
//   //      // debug
//               memset ((void *)&s8A_UsartDataTx, 0 , sizeof (s8A_UsartDataTx));
//               sprintf ((char *)s8A_UsartDataTx, "error = %X task: CommonSupportTasks_MainboardVoltageMonitoring\r", S_Exceptions.u32_ErrorCodeSW_Sub);
//               
//               UsartTx (0, 0, s8A_UsartDataTx, strlen((const char *)s8A_UsartDataTx), OS_T_MS(100));
//   //      // debug end            
//               
//               // set error codes to register bank
//               LibExceptionsFuncs_ExceptionSet (&S_Exceptions);
//            }
//            
//            os_dly_wait ((ushort)_OS_T_MS((ulong)AT91SAM7X__ADC_MAINBOARD_VOLTAGE_MONITORING_CLOCK_IN_MS, os_clockrate));
//         }
//      }
//      else
//      {
//         S_Exceptions.u32_ErrorCodeSW_Sub    = (ulong)LIB_EXCEPTIONS__ERROR_SPECIAL__ADC_INTERNAL_NOT_INITIALIZED;
//         S_Exceptions.u16_ErrorCodeSW_Base   = (ushort)LIB_EXCEPTIONS__ERROR__COMMON_SUPPORT_TASKS__TSK_MAINBOARD_VOLTAGE_MONITORING;
//      }
//   }
//   
//   // set error codes to register bank
//   LibExceptionsFuncs_ExceptionSet (&S_Exceptions);
//   
//   // update display
//   AT91F_PIO_ClearOutput (AT91SAM7X__BASE_PIO__DISP0_ATN, AT91SAM7X__PIN__DISP0_ATN);
//   
//   // quit this task because of not initialized ADC user channels
//   os_tsk_delete_self();
//}
